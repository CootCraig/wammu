Wammu installation
==================

It uses standard distutils, so:
python setup.py build
su
python setup.py install

You need python-gammu and wxPython [1] (Unicode enabled build) installed to
run and install this program. If you want support for scanning bluetooth
devices, you need PyBluez [2]. For incoming events notifications, you
need dbus-pyhon [3].

For Windows you also have to install Pywin32 [4].

If you want to obey dependency checking at build time for any reason,
you can use --skip-deps option.

[1]: http://wxpython.org/
[2]: http://org.csail.mit.edu/pybluez/
[3]: http://www.freedesktop.org/wiki/Software/DBusBindings
[4]: https://sourceforge.net/projects/pywin32/

Cross compilation for Windows on Linux
======================================

First we'll build wxWidgets and wxPython.

wxWidgets was built with that command line (adapted from BUILD.txt in
WX_2_8_BRANCH):

CXX=i586-mingw32msvc-g++ CC=i586-mingw32msvc-gcc ./configure --with-msw \
--host=i586-mingw32msvc --target=i586-mingw32msvc --prefix=/opt/wx/2.8 \
--enable-unicode --enable-optimise --enable-debug_flag --enable-shared --disable-rpath \
--with-expat=builtin --with-regex=builtin

To build windows python extentions, I prefered to use windows python
running with wine making python.exe/wine invoke linux's i386-mingw32-*
toolchain. This let distutils believe it can use the Cygwin/MinGW32
compiler (-mno-cygwin) without patching.

So, install wine and install python on wine:
msiexec /i python-2.5.1.msi

At the top of your wxPython source tree, copy MakeFakeWin.sh and
launch it with the first part of your mingw crosscompiler name without
'-gcc'. For example, if your mingw crosscompiler is called i586-mingw32msvc-gcc:
./MakeFakeWin.sh i586-mingw32msvc

Now gcc.exe, g++.exe, dllwrap.exe, dlltool.exe and wx-config.exe
have been created in CWD. These are links to a real windows executable
(wine_linux_launcher.exe) that call the locally created
wine_linux_launcher.sh script, with executable name + all invocation
arguments as parameters, and wait for result files for both return value
and stdout be created and finally pass result back to calling app, i.e.
python.exe, in the windows way... To summary, it let distutils do
os.popen and os.spawn as expected.
For the time being please replace in generated wine_linux_launcher.sh line
i586-mingw32msvc-$bzname $res > ${exename}_stdout
with line
i586-mingw32msvc-$bzname $res -lstdc++ > ${exename}_stdout

wine 'c:\Python25\python.exe' setup.py COMPILER=mingw32 CORE_ONLY=1 WX_CONFIG="wx-config" build
wine 'c:\Python25\python.exe' setup.py COMPILER=mingw32 CORE_ONLY=1 WX_CONFIG="wx-config" install -f

If wine complains about COMSPEC environment variable use
export COMSPEC=cmd.

Install PyWin32:
wine pywin32-210.win32-py2.5.exe

At the top of your wammu source tree, copy MakeFakeWin.sh and
launch it with the first part of your mingw crosscompiler name without
'-gcc'. For example, if your mingw crosscompiler is called i586-mingw32msvc-gcc:
./MakeFakeWin.sh i586-mingw32msvc

wine c:\\python25\\python setup.py build -c mingw32

TODO - create a package using py2exe.

Now you can run wine c:\\python25\\python wammu.py

If it complains (end of traceback):
  File "C:\Python25\lib\random.py", line 108, in seed
    a = long(_hexlify(_urandom(16)), 16)
WindowsError: [Error -2146893801] Windows Error 0x80090017

It's because of wine problem. Then use the following patch:

--- wammu.py.orig	2007-05-07 11:22:24.000000000 +0300
+++ wammu.py	2007-11-23 05:40:22.654590589 +0200
@@ -30,6 +30,9 @@
 import Wammu
 import Wammu.Locales
 
+def ni(i): raise NotImplementedError
+os.urandom = ni
+
 # Try to import iconv_codec to allow working on chinese windows
 try:
     import iconv_codec


# vim: et ts=4 sw=4 sts=4 tw=72 spell spelllang=en_us
